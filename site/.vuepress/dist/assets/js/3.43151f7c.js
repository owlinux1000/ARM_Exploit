(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{203:function(a,r,t){a.exports=t.p+"assets/img/image1.e5f26420.png"},204:function(a,r,t){a.exports=t.p+"assets/img/image2.5b5faa4b.png"},205:function(a,r,t){a.exports=t.p+"assets/img/image3.9679aee3.png"},206:function(a,r,t){a.exports=t.p+"assets/img/image4.78868e20.png"},212:function(a,r,t){"use strict";t.r(r);var e=t(0),_=Object(e.a)({},(function(){var a=this,r=a.$createElement,e=a._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"_4-playing-with-canary"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-playing-with-canary","aria-hidden":"true"}},[a._v("#")]),a._v(" 4. Playing with Canary")]),a._v(" "),e("p",[a._v("この章では、2章で少し頭出しをしたCanary についてもう少し深く見ていきます。Canary は、SSP によるBuffer Overflow を検知するための値です。x86においてCanaryは、"),e("code",[a._v("fs:[0x28]")]),a._v(" に格納されており、読み出すには若干手間がかかります。しかしながら、ARM においては別の場所に格納されています。本章ではARM におけるCanaryの特徴を簡単にご紹介します。")]),a._v(" "),e("h2",{attrs:{id:"_4-1-arm-におけるcanary"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-arm-におけるcanary","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.1 ARM におけるCanary")]),a._v(" "),e("p",[a._v("まずは、"),e("code",[a._v("bof2")]),a._v(" をgefで読み込んで、"),e("code",[a._v("start")]),a._v(" コマンドを入力してください。"),e("code",[a._v("bof2")]),a._v(" は、SSPを有効にした状態でコンパイルしています。\nSSP では、関数の先頭で、Canaryをスタックに配置する処理を行います。ここではその様子を見ていきます。")]),a._v(" "),e("p",[e("img",{attrs:{src:t(203),alt:"bof2の開始直後の様子"}})]),a._v(" "),e("p",[a._v("ここで、"),e("code",[a._v("ldr")]),a._v(" 命令により、0x105a8の値をr3レジスタにロードしようとしています。さらに、r3レジスタをアドレスとして指す値を、r3レジスタに格納しようとしています。その後、"),e("code",[a._v("str")]),a._v(" 命令によって、r3レジスタの値を、"),e("code",[a._v("[r11, #-8]")]),a._v(" つまりフレームポインタ-8のアドレスに格納しようしています。この時、r3レジスタにはどんな値が入っているか確認するために、"),e("code",[a._v("si")]),a._v("命令で2命令勧めて、"),e("code",[a._v("i r r3")]),a._v(" でr3レジスタの値を確認してみましょう。")]),a._v(" "),e("p",[e("img",{attrs:{src:t(204),alt:"Canaryの値"}})]),a._v(" "),e("p",[a._v("r3 レジスタには、0x1d7afc00という値が入っていることが確認できました。Canary の末尾1byteがNULL バイトであるという特徴にマッチしています。実は、この値がCanaryになっています。ここまで見てきたようにCanaryの値の元は、0x105a8に入っていました。このアドレスは、どこのセクションに位置するのか確認してみましょう。こういった際には、"),e("code",[a._v("xinfo")]),a._v(" コマンドが便利です。")]),a._v(" "),e("p",[e("img",{attrs:{src:t(205),alt:"xinfoの結果"}})]),a._v(" "),e("p",[a._v("xinfoの結果よりから、0x105a8は.textセクションに位置していることがわかりました。これは、つまりASLR の影響を受けないことを意味しています。また、ROPなどでリークが簡単にできるアドレスに格納されているため、他の脆弱性と合わせることで、Canary をリークすることが可能となります。")]),a._v(" "),e("p",[a._v("最後にCanary の比較処理を見てみましょう。main+88の周辺を見てみましょう。")]),a._v(" "),e("p",[e("img",{attrs:{src:t(206),alt:"Canaryの検査部分"}})]),a._v(" "),e("p",[a._v("最初の命令では、0x105a8から値をr3レジスタにロードしています。次に、Canaryを保存していた"),e("code",[a._v("[r11, #-8]")]),a._v("からr2レジスタに値をロードしています。その後、r3レジスタをアドレスとして指す値をr3レジスタにロードしています。これにより、元のCanaryの値をr3レジスタに格納できます。その後、"),e("code",[a._v("cmp")]),a._v(" 命令で、スタック上のCanaryであるr2と、元のCanaryであるr3レジスタを比較して、等しければ"),e("code",[a._v("<main+112>")]),a._v("にジャンプ（"),e("code",[a._v("beq")]),a._v("は等しければジャンプする）し、終了処理に向かいます。しかし等しくなければ、"),e("code",[a._v("stack_chk_fail")]),a._v(" という強制終了処理が走る関数を実行します。")]),a._v(" "),e("h2",{attrs:{id:"_4-2-まとめ"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-まとめ","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.2 まとめ")]),a._v(" "),e("p",[a._v("本章では、ARM におけるCanaryについて見てきました。ARM のCanaryの値は、"),e("code",[a._v(".text")]),a._v(" セクションに格納されているため、他の脆弱性と組み合わせることで、Canaryをリークして、SSP をバイパスすることが可能となります。これは、x86系と異なる仕組みなのでARM Exploit開発をする上で重要な知見だといえます。")])])}),[],!1,null,null,null);r.default=_.exports}}]);