# スタックベースのバッファオーバーフロー

## はじめに

本章では、古典的なスタックベースのバッファオーバーフローについて見ていきます。Exploit 経験者であれば、本章の内容はx86 アーキテクチャなどと差異はほとんどないと思うでしょう。簡単にバッファオーバーフローの原理について紹介した後に、前章で作成したシェルコードを使ってシェルを奪う演習問題を解いていきます。

## スタックベースのバッファオーバーフローの原理

バッファオーバーフローは、予め設計されたバッファのサイズを超える読み込みを許容してしまう脆弱性のことです。Linux においてあるプロセスが実行されると、スタック領域が確保されローカル変数の領域として利用します。ここでは、このスタック領域でのバッファオーバーフローが起こる際の挙動について記載します。まずは以下のプログラムを見てみましょう（bof.c）。

```
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char* argv[]) {
    char buf[0x100];
    setbuf(stdout, NULL);
    printf("stack: %p\n", buf);
    gets(buf);
    return 0;
}
```

本プログラムでは、入力長さの長さを指定できない`gets` 関数を使用しています。意図されたバッファのサイズは0x100なので、これ以上の入力をすることでスタックの後続の領域を上書きすることが可能となります。スタックには、`return 0` で元の関数に戻るためのリターンアドレスが格納や関数内部のスタックのベースを示すフレームポインタが格納されています。本プログラムのスタックの使われ方を図示すると以下のようになります。図示されているアドレスはあくまで例です。

|アドレス|値|
|:---:|:---:|
|0x1000| buf |
|0x1100| フレームポインタ|
|0x1104| リターンアドレス|

上記の図より、0x100 を超える入力を行うことで、関数の戻り先であるリターンアドレスを上書きして制御を奪うことが可能となります。この時、戻り先をどこに書き換えればよいかという点が重要ですが、今回のプログラムでは、スタックのアドレスである`buf` 変数のアドレスをリークしてくれているため、このアドレスにジャンプすることで、入力したシェルコードを実行することが可能となります。ただし、最近のgcc などでは、スタック領域など読み書きすることのみを想定された領域では、実行権限が付与されていないため通常では入力したシェルコードを実行することができません。今回は、gcc のセキュリティ機構を無効にした状態でコンパイルすることで、実行権限を付与しているため本攻撃が通用します。gef では、対象ファイルを選択した状態であれば、`checksec` コマンドを使うことでセキュリティ機構を確認できます。
